<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinfonía Visual (Explosión)</title>
    <style>
        :root { --cursor-size: 10px; --cursor-bg: white; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes reveal {
            from { opacity: 0; transform: translateY(30px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; cursor: none; background-color: #000; }

        #background-video, #particle-canvas, #drawing-canvas {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
        }

        #background-video { z-index: 1; filter: blur(50px) brightness(0.6); object-fit: cover; animation: fadeIn 1.5s ease-out; }
        #particle-canvas { z-index: 2; }
        #drawing-canvas { z-index: 4; mix-blend-mode: difference; pointer-events: none; }
        
        .perspective-wrapper {
            display: flex; justify-content: center; align-items: center;
            height: 100%;
            perspective: 1500px;
            position: relative;
            z-index: 3;
        }

        .video-container {
            position: relative;
            width: 640px; max-width: 90%;
            transform-style: preserve-3d;
            transition: transform 0.1s linear;
            animation: reveal 1s ease-out 0.5s backwards;
            pointer-events: none;
        }

        #video-card {
            position: relative; background-color: black;
            border-radius: 16px; overflow: hidden;
            box-shadow: 0 25px 60px rgba(0,0,0,0.4);
            transform: translateZ(0);
            transition: transform 0.4s ease, box-shadow 0.4s ease;
        }

        #video-card::after {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 70%);
            border-radius: 16px; opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.4s ease, transform 0.4s ease;
            z-index: 2;
        }

        .video-container:hover #video-card { transform: translateY(-15px) scale(1.05); box-shadow: 0 40px 80px rgba(0,0,0,0.3); }
        .video-container:hover #video-card::after { opacity: 1; transform: scale(1); }
        #miVideo { display: block; width: 100%; height: auto; }
        
        #video-title {
            color: white; font-family: 'Helvetica Neue', 'Arial', sans-serif;
            font-weight: 400; font-size: 1.2rem;
            text-align: center; margin-top: 25px;
            opacity: 0.8; letter-spacing: 0.5px;
            transition: transform 0.4s ease, opacity 0.4s ease;
        }
        .video-container:hover #video-title { transform: translateY(-15px); opacity: 1; }
        
        #mute-btn {
            position: absolute; top: 20px; right: 20px;
            z-index: 10;
            background: none; border: none; padding: 0;
            cursor: none; width: 28px; height: 28px;
            pointer-events: auto;
        }
        #mute-btn svg {
            width: 100%; height: 100%; fill: white;
            mix-blend-mode: difference; 
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
            transition: transform 0.2s;
        }
        
        #custom-cursor {
            position: fixed; width: var(--cursor-size); height: var(--cursor-size);
            background-color: var(--cursor-bg);
            border-radius: 50%; top: 0; left: 0;
            transform: translate(-50%, -50%);
            pointer-events: none; mix-blend-mode: difference;
            z-index: 9999;
            transition: transform 0.2s ease-out, opacity 0.5s ease-out;
        }
        #custom-cursor.hidden { opacity: 0; }
    </style>
</head>
<body>
    <div id="custom-cursor"></div>
    <canvas id="particle-canvas"></canvas>
    <canvas id="drawing-canvas"></canvas>

    <video id="background-video" loop muted disableRemotePlayback playsinline>
        <source src="Laufey.mp4" type="video/mp4">
    </video>

    <div class="perspective-wrapper" id="perspective-wrapper">
        <div class="video-container">
            <div id="video-card">
                <video id="miVideo" loop muted disableRemotePlayback playsinline>
                    <source src="Laufey.mp4" type="video/mp4">
                </video>
                <button id="mute-btn">
                    <svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
                </button>
            </div>
            <div id="video-title">Pagina Hecho Para Pruebas :)</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const mainVideo = document.getElementById('miVideo');
            const bgVideo = document.getElementById('background-video');
            const muteBtn = document.getElementById('mute-btn');
            const videoContainer = document.querySelector('.video-container');
            const cursor = document.getElementById('custom-cursor');
            const drawingCanvas = document.getElementById('drawing-canvas');
            const particleCanvas = document.getElementById('particle-canvas');
            const dCtx = drawingCanvas.getContext('2d');
            const pCtx = particleCanvas.getContext('2d');

            const videoReady = (vid) => new Promise(resolve => vid.addEventListener('canplaythrough', resolve, { once: true }));
            Promise.all([videoReady(mainVideo), videoReady(bgVideo)]).then(() => {
                mainVideo.play(); bgVideo.play();
                const syncLoop = () => {
                    if (Math.abs(mainVideo.currentTime - bgVideo.currentTime) > 0.1) bgVideo.currentTime = mainVideo.currentTime;
                    requestAnimationFrame(syncLoop);
                };
                syncLoop();
            });

            let cursorIdleTimer;
            document.addEventListener('mousemove', (e) => {
                cursor.classList.remove('hidden');
                clearTimeout(cursorIdleTimer);
                cursorIdleTimer = setTimeout(() => cursor.classList.add('hidden'), 2000);
                const { innerWidth, innerHeight } = window;
                videoContainer.style.transform = `rotateX(${(e.clientY / innerHeight - 0.5) * -20}deg) rotateY(${(e.clientX / innerWidth - 0.5) * 20}deg)`;
                cursor.style.left = `${e.clientX}px`; cursor.style.top = `${e.clientY}px`;
            });

            let isDrawing = false, lastX = 0, lastY = 0;
            const resizeDrawingCanvas = () => { drawingCanvas.width = window.innerWidth; drawingCanvas.height = window.innerHeight; };
            resizeDrawingCanvas(); window.addEventListener('resize', resizeDrawingCanvas);
            dCtx.strokeStyle = '#FFF'; dCtx.lineWidth = 3; dCtx.lineCap = 'round'; dCtx.lineJoin = 'round';
            const getCoords = (e) => e.touches ? [e.touches[0].clientX, e.touches[0].clientY] : [e.clientX, e.clientY];
            const handleStart = (e) => { isDrawing = true; [lastX, lastY] = getCoords(e); };
            const handleEnd = () => isDrawing = false;
            const draw = (e) => {
                if (e.touches) e.preventDefault();
                if (!isDrawing) return;
                dCtx.beginPath(); dCtx.moveTo(lastX, lastY);
                const [currentX, currentY] = getCoords(e);
                dCtx.lineTo(currentX, currentY); dCtx.stroke();
                [lastX, lastY] = [currentX, currentY];
            };
            const fadeDrawingTrail = () => {
                dCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                dCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                requestAnimationFrame(fadeDrawingTrail);
            };

            let audioContext, analyser, source;
            muteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                muteBtn.style.display = 'none';

                drawingCanvas.style.pointerEvents = 'auto';
                drawingCanvas.addEventListener('mousedown', handleStart);
                drawingCanvas.addEventListener('mousemove', draw);
                drawingCanvas.addEventListener('mouseup', handleEnd);
                drawingCanvas.addEventListener('mouseleave', handleEnd);
                drawingCanvas.addEventListener('touchstart', handleStart, { passive: false });
                drawingCanvas.addEventListener('touchmove', draw, { passive: false });
                drawingCanvas.addEventListener('touchend', handleEnd);
                fadeDrawingTrail();
                
                mainVideo.muted = false;

                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    source = audioContext.createMediaElementSource(mainVideo);
                    analyser = audioContext.createAnalyser();
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                }
                audioContext.resume();
                initParticles();
                animateParticles();
            }, { once: true });

            // --- PARTÍCULAS "FUEGOS ARTIFICIALES" ---
            let particlesArray;
            const resizeParticleCanvas = () => { particleCanvas.width = window.innerWidth; particleCanvas.height = window.innerHeight; };
            resizeParticleCanvas(); window.addEventListener('resize', resizeParticleCanvas);
            
            class Particle {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = particleCanvas.width / 2;
                    this.y = particleCanvas.height / 2;
                    this.angle = Math.random() * Math.PI * 2;
                    this.radius = Math.random() * 1.5 + 0.5;
                    this.speed = Math.random() * 1.5 + 0.5;
                    this.color = 'rgba(255, 255, 255, 0.8)';
                }

                update(bass, treble) {
                    // Los graves disparan las partículas hacia afuera
                    const bassBoost = bass / 20;
                    this.x += Math.cos(this.angle) * (this.speed + bassBoost);
                    this.y += Math.sin(this.angle) * (this.speed + bassBoost);

                    // Los agudos aumentan el brillo (opacidad)
                    const opacity = Math.max(0.3, Math.min(1, treble / 100));
                    this.color = `rgba(255, 255, 255, ${opacity})`;

                    // Si la partícula se sale, reiníciala en el centro
                    if (this.x < 0 || this.x > particleCanvas.width || this.y < 0 || this.y > particleCanvas.height) {
                        this.reset();
                    }
                }

                draw() {
                    pCtx.fillStyle = this.color;
                    pCtx.beginPath();
                    pCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    pCtx.fill();
                }
            }

            function initParticles() {
                particlesArray = [];
                for (let i = 0; i < 250; i++) {
                    particlesArray.push(new Particle());
                }
            }

            function animateParticles() {
                if (!analyser) return;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);
                
                const bass = dataArray.slice(0, Math.floor(bufferLength * 0.2)).reduce((a, b) => a + b, 0) / (bufferLength * 0.2);
                const treble = dataArray.slice(Math.floor(bufferLength * 0.5)).reduce((a, b) => a + b, 0) / (bufferLength * 0.5);

                pCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
                particlesArray.forEach(p => { 
                    p.update(bass, treble);
                    p.draw();
                });
                
                requestAnimationFrame(animateParticles);
            }
        });
    </script>
</body>
</html>
